const socket = io();

// Grid data
let grid = [];
let players = {};
let myScore = 0;

// References
let timeLeftElem = document.getElementById("timeLeft");
let myScoreElem = document.getElementById("yourScore");
let scoreboardDiv = document.getElementById("scoreboard");

// Canvas
let canvas = document.getElementById("gameCanvas");
let ctx = canvas.getContext("2d");

// For auto-scaling & centering the grid
let cellSize = 50;
let offsetX = 0;
let offsetY = 0;
let margin = 50; // margin inside the canvas

// Drag selection
let isDragging = false;
let startX = 0, startY = 0;
let currentX = 0, currentY = 0;

// Fade-out (now drop animation)
let removingApples = []; // Each entry: { row, col, value, startTime, duration, dropDistance }

// Remote cursors
let remoteCursors = {};

// For assigning player names
let playerNames = {};
let nextPlayerNumber = 1;

/**
 * Returns a unique color for a player based on their ID.
 */
function getPlayerColor(playerId) {
  const colors = ["blue", "orange", "purple", "cyan", "magenta", "lime", "gold", "pink"];
  let hash = 0;
  for (let i = 0; i < playerId.length; i++) {
    hash = playerId.charCodeAt(i) + ((hash << 5) - hash);
  }
  const index = Math.abs(hash) % colors.length;
  return colors[index];
}

/**
 * Utility: Calculate overlap area between two rectangles.
 */
function getRectOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
  const overlapX = Math.max(0, Math.min(ax + aw, bx + bw) - Math.max(ax, bx));
  const overlapY = Math.max(0, Math.min(ay + ah, by + bh) - Math.max(ay, by));
  return overlapX * overlapY;
}

/**
 * Scale & center the grid in the canvas,
 * leaving a margin on all sides.
 */
function autoScaleGrid() {
  if (!grid || grid.length === 0) return;
  const rows = grid.length;
  const cols = grid[0].length;
  
  // Available area is canvas size minus 2*margin
  const availableWidth = canvas.width - margin * 2;
  const availableHeight = canvas.height - margin * 2;
  
  const scaleX = Math.floor(availableWidth / cols);
  const scaleY = Math.floor(availableHeight / rows);
  cellSize = Math.min(scaleX, scaleY);
  
  const gridWidth = cols * cellSize;
  const gridHeight = rows * cellSize;
  offsetX = margin + (availableWidth - gridWidth) / 2;
  offsetY = margin + (availableHeight - gridHeight) / 2;
}

/**
 * Update scoreboard with player names and scores.
 */
function updateScoreboard() {
  let html = "<h3>Scoreboard</h3><ul>";
  for (let pid in players) {
    if (!playerNames[pid]) {
      playerNames[pid] = "Player " + nextPlayerNumber;
      nextPlayerNumber++;
    }
    let name = playerNames[pid];
    let color = getPlayerColor(pid);
    let score = players[pid].score || 0;
    html += `<li style="color: ${color};">${name}: ${score}</li>`;
  }
  html += "</ul>";
  if (scoreboardDiv) {
    scoreboardDiv.innerHTML = html;
  }
}

/**
 * Main draw loop.
 */
function drawGame() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  if (!grid || grid.length === 0) {
    requestAnimationFrame(drawGame);
    return;
  }
  
  const rows = grid.length;
  const cols = grid[0].length;
  
  // Draw grid cell lines
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let x = offsetX + c * cellSize;
      let y = offsetY + r * cellSize;
      ctx.strokeStyle = "#b2e6be";
      ctx.strokeRect(x, y, cellSize, cellSize);
    }
  }
  
  // Draw remote players' cursors and selection boxes
  for (let pid in remoteCursors) {
    let data = remoteCursors[pid];
    const color = getPlayerColor(pid);
    ctx.save();
    // Draw cursor as a small circle
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(data.x, data.y, 5, 0, 2 * Math.PI);
    ctx.fill();
    // Draw selection rectangle if dragging
    if (data.isDragging && data.selection) {
      let { startX: sX, startY: sY, currentX: cX, currentY: cY } = data.selection;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.strokeRect(Math.min(sX, cX), Math.min(sY, cY), Math.abs(sX - cX), Math.abs(sY - cY));
    }
    ctx.restore();
  }
  
  // If dragging locally, highlight selected apples with a ring
  if (isDragging) {
    highlightSelectedApples();
  }
  
  // Draw local apples (skip ones being removed)
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (grid[r][c] > 0) {
        let isRemoving = removingApples.some(a => a.row === r && a.col === c);
        if (!isRemoving) {
          let x = offsetX + c * cellSize;
          let y = offsetY + r * cellSize;
          drawApple(x, y, grid[r][c], 1.0, 1.0);
        }
      }
    }
  }
  
  // Animate dropped apples (drop animation instead of fade)
  drawDroppedApples();
  
  // Draw local selection rectangle if dragging
  if (isDragging) {
    drawSelectionRect();
  }
  
  requestAnimationFrame(drawGame);
}

/**
 * Highlight selected apples (local) with a ring.
 */
function highlightSelectedApples() {
  const selX = Math.min(startX, currentX);
  const selY = Math.min(startY, currentY);
  const selW = Math.abs(startX - currentX);
  const selH = Math.abs(startY - currentY);
  
  const rows = grid.length;
  const cols = grid[0].length;
  
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (grid[r][c] > 0) {
        let x = offsetX + c * cellSize;
        let y = offsetY + r * cellSize;
        const overlapArea = getRectOverlap(selX, selY, selW, selH, x, y, cellSize, cellSize);
        const cellArea = cellSize * cellSize;
        if (overlapArea >= cellArea / 2) {
          const appleRadius = cellSize / 2 - 5;
          const ringRadius = appleRadius + 4;
          ctx.save();
          ctx.strokeStyle = "rgba(255, 255, 0, 0.8)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(x + cellSize / 2, y + cellSize / 2, ringRadius, 0, 2 * Math.PI);
          ctx.stroke();
          ctx.restore();
        }
      }
    }
  }
}

/**
 * Draw a single apple: red circle with bold white number.
 */
function drawApple(x, y, value, alpha, scale) {
  const radius = (cellSize / 2 - 5) * scale;
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(x + cellSize / 2, y + cellSize / 2, radius, 0, 2 * Math.PI);
  ctx.fill();
  
  ctx.fillStyle = "white";
  // Make numbers bold by using "bold" in the font style
  ctx.font = `bold ${Math.floor(20 * scale)}px Arial`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(value, x + cellSize / 2, y + cellSize / 2);
  ctx.restore();
}

/**
 * Animate removed apples with a drop animation.
 * Instead of fading, apples drop vertically.
 */
function drawDroppedApples() {
  const now = performance.now();
  for (let i = removingApples.length - 1; i >= 0; i--) {
    const apple = removingApples[i];
    const elapsed = now - apple.startTime;
    if (elapsed >= apple.duration) {
      removingApples.splice(i, 1);
    } else {
      let progress = elapsed / apple.duration;
      // Compute drop: apple moves downward by dropDistance
      let dropDistance = apple.dropDistance;
      let drop = dropDistance * progress;
      let x = offsetX + apple.col * cellSize;
      // Original y plus drop offset
      let y = offsetY + apple.row * cellSize + drop;
      drawApple(x, y, apple.value, 1.0, 1.0);
    }
  }
}

/**
 * Draw the selection rectangle.
 */
function drawSelectionRect() {
  const selX = Math.min(startX, currentX);
  const selY = Math.min(startY, currentY);
  const selW = Math.abs(startX - currentX);
  const selH = Math.abs(startY - currentY);
  ctx.strokeStyle = "blue";
  ctx.lineWidth = 2;
  ctx.strokeRect(selX, selY, selW, selH);
}

/**
 * Finalize selection and emit selected cells to the server.
 */
function finalizeSelection() {
  const selX = Math.min(startX, currentX);
  const selY = Math.min(startY, currentY);
  const selW = Math.abs(startX - currentX);
  const selH = Math.abs(startY - currentY);
  
  const rows = grid.length;
  const cols = grid[0].length;
  
  let selectedCells = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let x = offsetX + c * cellSize;
      let y = offsetY + r * cellSize;
      const overlapArea = getRectOverlap(selX, selY, selW, selH, x, y, cellSize, cellSize);
      const cellArea = cellSize * cellSize;
      if (overlapArea >= cellArea / 2) {
        selectedCells.push({ row: r, col: c });
      }
    }
  }
  socket.emit("selectApples", { cells: selectedCells });
}

// ----------------------------------------------------
// Socket.IO events
// ----------------------------------------------------
socket.on("gameState", (data) => {
  grid = data.grid;
  players = data.players;
  autoScaleGrid();
  updateScoreboard();
});

socket.on("selectionSuccess", (data) => {
  const { removed, playerId, newScore } = data;
  players[playerId].score = newScore;
  if (playerId === socket.id) {
    myScore = newScore;
    myScoreElem.textContent = myScore;
  }
  // Instead of fade-out, use drop animation.
  removed.forEach(({ row, col }) => {
    let oldValue = grid[row][col];
    if (oldValue < 1) oldValue = 1;
    // Push drop animation object with a dropDistance (e.g., 50px)
    removingApples.push({
      row,
      col,
      value: oldValue,
      startTime: performance.now(),
      duration: 500,
      dropDistance: 50
    });
    grid[row][col] = 0;
  });
  updateScoreboard();
});

socket.on("selectionFail", (data) => {
  console.log("Selection failed:", data.reason);
});

socket.on("timerUpdate", (data) => {
  timeLeftElem.textContent = data.timeLeft;
});

socket.on("gameOver", (data) => {
  console.log("Game Over! Final Scores:", data.players);
  const modal = document.getElementById("gameOverModal");
  const finalScoreElem = document.getElementById("finalScore");
  finalScoreElem.innerText = `Your Score: ${myScore}`;
  modal.style.display = "flex";
  updateScoreboard();
});

// --- Remote Cursor Handling ---
socket.on("updateCursor", (data) => {
  // Data: { playerId, x, y, isDragging, selection }
  remoteCursors[data.playerId] = data;
});
socket.on("removeCursor", (data) => {
  delete remoteCursors[data.playerId];
});

// Emit local cursor/selection info
function emitCursor() {
  socket.emit("playerCursor", {
    x: currentX,
    y: currentY,
    isDragging: isDragging,
    selection: { startX, startY, currentX, currentY }
  });
}

// ----------------------------------------------------
// Background Music and Sound Effects
// ----------------------------------------------------
const popSound = new Audio("pop.mp3");
const bgm = new Audio("boss.mp3");
const bgm2 = new Audio("oia.m4a");
const bgm3 = new Audio("chill.m4a");
const bgm4 = new Audio("anime.m4a");
bgm.loop = true;
bgm.volume = 0.5; // adjust volume if needed
bgm2.loop = true;
bgm2.volume = 0.5; // adjust volume if needed
bgm3.loop = true;
bgm3.volume = 0.5; // adjust volume if needed
bgm4.loop = true;
bgm4.volume = 0.5; // adjust volume if needed
// Play pop sound on selection success
socket.on("selectionSuccess", (data) => {
  popSound.currentTime = 0;
  popSound.play();
});

// BGM toggle
document.getElementById("bgmToggle").addEventListener("change", (e) => {
  if (e.target.checked) {
    bgm.play();
  } else {
    bgm.pause();
  }
});
document.getElementById("bgm2Toggle").addEventListener("change", (e) => {
    if (e.target.checked) {
      bgm2.play();
    } else {
      bgm2.pause();
    }
  });
  document.getElementById("bgm3Toggle").addEventListener("change", (e) => {
    if (e.target.checked) {
      bgm3.play();
    } else {
      bgm3.pause();
    }
  });
  document.getElementById("bgm4Toggle").addEventListener("change", (e) => {
    if (e.target.checked) {
      bgm4.play();
    } else {
      bgm4.pause();
    }
  });
// ----------------------------------------------------
// Mouse & UI Setup
// ----------------------------------------------------

// Attach mouse events to the canvas
canvas.addEventListener("mousedown", (e) => {
  isDragging = true;
  const rect = canvas.getBoundingClientRect();
  startX = e.clientX - rect.left;
  startY = e.clientY - rect.top;
  currentX = startX;
  currentY = startY;
  emitCursor();
});

canvas.addEventListener("mousemove", (e) => {
  const rect = canvas.getBoundingClientRect();
  currentX = e.clientX - rect.left;
  currentY = e.clientY - rect.top;
  if (isDragging) {
    emitCursor();
  }
});

canvas.addEventListener("mouseup", (e) => {
  if (isDragging) {
    isDragging = false;
    finalizeSelection();
    emitCursor();
  }
});

// Reset button
document.getElementById("resetButton").addEventListener("click", () => {
  socket.emit("restartGame");
});

// Optional toggles (Light Colors already handled below)
document.getElementById("lightColors").addEventListener("change", (e) => {
  console.log("Light Colors toggled:", e.target.checked);
});

// Close modal
document.getElementById("closeModal").addEventListener("click", () => {
  document.getElementById("gameOverModal").style.display = "none";
});

// Start loop
autoScaleGrid();
requestAnimationFrame(drawGame);
<!DOCTYPE html>
<html>
<head>
  <title>Fruit Box Multiplayer</title>
  <meta charset="utf-8">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="frame">
    <div id="gameContainer">
      <!-- Larger canvas for extra space -->
      <canvas id="gameCanvas" width="1200" height="1000"></canvas>
      
      <!-- Score display on top-right -->
      <div id="scoreDisplay">
        Score: <span id="yourScore">0</span>
      </div>
      
      <!-- Timer on top-left -->
      <div id="timerDisplay">
        Time Left: <span id="timeLeft">0</span>
      </div>
      
      <!-- Scoreboard on the right -->
      <div id="scoreboard"></div>
      
      <!-- Bottom bar with Reset, toggles, etc. -->
      <div id="bottomBar">
        <button id="resetButton">Reset</button>
        <div id="toggles">
          <label><input type="checkbox" id="lightColors"> Light Colors</label>
          <label><input type="checkbox" id="bgmToggle"> Boss </label>
          <label><input type="checkbox" id="bgm2Toggle"> OIA </label>
          <label><input type="checkbox" id="bgm3Toggle"> Chill </label>
          <label><input type="checkbox" id="bgm4Toggle"> Anime </label>
        </div>
      </div>
    </div>
    
    <!-- Modal for game over -->
    <div id="gameOverModal" class="modal">
      <div class="modal-content">
        <h2>Game Over!</h2>
        <p id="finalScore">Your Score: 0</p>
        <button id="closeModal">Close</button>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="client.js"></script>
</body>
</html>
/* Body background */
body {
    margin: 0;
    padding: 0;
    font-family: Arial, sans-serif;
    background-color: #66cc99; /* Light green */
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  
  /* Outer green frame */
  #frame {
    background-color: #58b666;
    border: 6px solid #33a644;
    border-radius: 10px;
    padding: 10px;
  }
  
  /* Main container for the game */
  #gameContainer {
    position: relative;
    background-color: #c9f2d3;
    width: 1220px;  /* slightly bigger than the 1200x1000 canvas */
    height: 1020px;
    box-shadow: inset 0 0 0 2px #b2e6be;
  }
  
  /* The grid canvas */
  #gameCanvas {
    position: absolute;
    left: 10px;
    top: 10px;
    background-color: #daf7e2;
    box-shadow: inset 0 0 0 1px #b2e6be;
  }
  
  /* Score display in top-right */
  #scoreDisplay {
    position: absolute;
    top: 10px;
    right: 20px;
    font-size: 20px;
    color: #fff;
    background-color: #33a644;
    padding: 5px 10px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
  }
  
  /* Timer in top-left */
  #timerDisplay {
    position: absolute;
    top: 10px;
    left: 20px;
    font-size: 18px;
    color: #fff;
    background-color: #33a644;
    padding: 5px 10px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
  }
  
  /* Scoreboard on the right */
  #scoreboard {
    position: absolute;
    top: 100px;
    right: -240px;  /* outside the game container */
    width: 180px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 10px;
    border-radius: 5px;
    font-size: 16px;
    color: #333;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
  }
  
  /* Bottom bar */
  #bottomBar {
    position: absolute;
    bottom: 10px;
    left: 10px;
    right: 10px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  
  /* Reset button */
  #resetButton {
    font-size: 16px;
    padding: 5px 10px;
    border: 2px solid #33a644;
    background-color: #c9f2d3;
    color: #33a644;
    border-radius: 4px;
    cursor: pointer;
  }
  #resetButton:hover {
    background-color: #b2e6be;
  }
  
  /* Toggles (Light Colors, BGM) */
  #toggles {
    font-size: 14px;
    color: #33a644;
  }
  
  /* Modal overlay */
  .modal {
    position: fixed;
    z-index: 100;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: none;
    justify-content: center;
    align-items: center;
  }
  
  /* Modal content */
  .modal-content {
    background: #fff;
    padding: 20px 30px;
    border-radius: 5px;
    text-align: center;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.3);
  }
  const express = require("express");
  const http = require("http");
  const socketIO = require("socket.io");
  
  const app = express();
  const server = http.createServer(app);
  const io = socketIO(server);
  
  app.use(express.static("public")); // Serve front-end files from /public
  
  // Grid configuration
  const GRID_ROWS = 15;
  const GRID_COLS = 20;
  
  // Global game state
  let grid = [];
  let players = {};
  let gameDuration = 60; // seconds
  let gameActive = false;
  let timerInterval;
  
  // Global object to track players' cursors
  let playerCursors = {};
  
  /** Shuffle array (Fisher-Yates). */
  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }
  
  /**
   * Create a grid with an even distribution of numbers 1..9,
   * then shuffle for better solvability.
   */
  function createGrid(rows = GRID_ROWS, cols = GRID_COLS) {
    const totalCells = rows * cols;
    let numbers = [];
    const countEach = Math.floor(totalCells / 9);
    for (let n = 1; n <= 9; n++) {
      for (let i = 0; i < countEach; i++) {
        numbers.push(n);
      }
    }
    while (numbers.length < totalCells) {
      numbers.push(Math.floor(Math.random() * 9) + 1);
    }
    numbers = shuffleArray(numbers);
    let newGrid = [];
    for (let r = 0; r < rows; r++) {
      let row = [];
      for (let c = 0; c < cols; c++) {
        row.push(numbers[r * cols + c]);
      }
      newGrid.push(row);
    }
    return newGrid;
  }
  
  /** Start a new game: create grid, reset scores, broadcast state, start timer. */
  function startGame() {
    grid = createGrid();
    gameActive = true;
    Object.values(players).forEach((p) => (p.score = 0));
    io.emit("gameState", {
      grid,
      players,
      timeLeft: gameDuration,
    });
    let timeLeft = gameDuration;
    timerInterval = setInterval(() => {
      timeLeft--;
      if (timeLeft <= 0) {
        endGame();
      } else {
        io.emit("timerUpdate", { timeLeft });
      }
    }, 1000);
  }
  
  /** End the current game session. */
  function endGame() {
    clearInterval(timerInterval);
    gameActive = false;
    io.emit("gameOver", { players });
  }
  
  // Socket.IO events
  io.on("connection", (socket) => {
    console.log(`New client connected: ${socket.id}`);
    players[socket.id] = { playerId: socket.id, score: 0 };
  
    if (gameActive) {
      socket.emit("gameState", { grid, players });
    }
  
    // Listen for player's cursor updates
    socket.on("playerCursor", (data) => {
      // data: { x, y, isDragging, selection: { startX, startY, currentX, currentY } }
      playerCursors[socket.id] = data;
      // Broadcast to everyone except sender
      socket.broadcast.emit("updateCursor", { playerId: socket.id, ...data });
    });
  
    // Handle apple selection
    socket.on("selectApples", (data) => {
      if (!gameActive || !data.cells) return;
      let sum = 0;
      let validCells = [];
      for (let cell of data.cells) {
        const { row, col } = cell;
        if (grid[row] && grid[row][col] && grid[row][col] > 0) {
          sum += grid[row][col];
          validCells.push({ row, col });
        }
      }
      if (sum === 10 && validCells.length > 0) {
        validCells.forEach(({ row, col }) => {
          grid[row][col] = 0;
        });
        players[socket.id].score += 1;
        io.emit("selectionSuccess", {
          removed: validCells,
          playerId: socket.id,
          newScore: players[socket.id].score,
        });
      } else {
        socket.emit("selectionFail", {
          reason: "Sum not 10 or cells invalid.",
        });
      }
    });
  
    // Restart game
    socket.on("restartGame", () => {
      console.log("Restarting game at the request of:", socket.id);
      endGame();
      startGame();
    });
  
    socket.on("disconnect", () => {
      console.log(`Client disconnected: ${socket.id}`);
      delete players[socket.id];
      delete playerCursors[socket.id];
      socket.broadcast.emit("removeCursor", { playerId: socket.id });
    });
  });
  
  // Start the server
  const PORT = process.env.PORT || 3000;
  server.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
    startGame();
  });
  